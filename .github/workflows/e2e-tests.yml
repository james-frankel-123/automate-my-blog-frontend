name: E2E Tests

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches:
      - main
      - staging
      - 'feat/**'
      - 'fix/**'
    paths:
      - 'src/**'
      - 'public/**'
      - 'e2e/**'
      - 'package.json'
      - 'package-lock.json'
      - 'playwright.config.js'
      - 'vercel.json'
      - '.github/workflows/e2e-tests.yml'
      - '.github/workflows/deploy.yml'
  pull_request:
    branches:
      - main
      - staging
    paths:
      - 'src/**'
      - 'public/**'
      - 'e2e/**'
      - 'package.json'
      - 'package-lock.json'
      - 'playwright.config.js'
      - 'vercel.json'
      - '.github/workflows/e2e-tests.yml'
      - '.github/workflows/deploy.yml'
  # Run when a PR is in the merge queue so required E2E check can pass
  merge_group:
  workflow_dispatch: # Allow manual triggering
  workflow_call: {} # Allow ci.yml to call this workflow

jobs:
  e2e-tests:
    name: Run E2E Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        
      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci

      - name: Cache Playwright browsers
        uses: actions/cache@v5
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ hashFiles('package-lock.json') }}
        
      - name: Install Playwright browsers (cache miss)
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        run: npx playwright install --with-deps chromium
        
      - name: Install Playwright OS dependencies only (browsers from cache)
        if: steps.playwright-cache.outputs.cache-hit == 'true'
        run: npx playwright install-deps chromium
          
      - name: Run E2E tests
        run: npm run test:e2e
        env:
          CI: true
          PLAYWRIGHT_BASE_URL: http://localhost:3000
          # Disable webServer auto-start since we're in CI
          # Playwright will handle server startup via webServer config
          
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v6
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30
          
      - name: Upload test videos
        if: failure()
        uses: actions/upload-artifact@v6
        with:
          name: test-videos
          path: test-results/**/*.webm
          retention-days: 7
          
      - name: Upload screenshots
        if: failure()
        uses: actions/upload-artifact@v6
        with:
          name: test-screenshots
          path: test-results/**/*.png
          retention-days: 7
          
      - name: Upload test results JSON
        if: always()
        uses: actions/upload-artifact@v6
        with:
          name: e2e-results
          path: e2e-results.json
          retention-days: 30

  comment-on-e2e-failure:
    name: Comment on PR when E2E fails
    runs-on: ubuntu-latest
    if: failure() && github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository
    needs: e2e-tests
    permissions:
      pull-requests: write
    steps:
      - name: Download E2E results
        uses: actions/download-artifact@v6
        continue-on-error: true
        with:
          name: e2e-results
          path: e2e-results-artifact

      - name: Comment E2E failure explanation on PR
        uses: actions/github-script@v8
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_TOKEN_FOR_GITHUB_ACTIONS }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            function collectFailures(obj, out, title) {
              if (!obj) return;
              if (Array.isArray(obj)) {
                obj.forEach(item => collectFailures(item, out, title));
                return;
              }
              if (obj.specs) {
                obj.specs.forEach(s => collectFailures(s, out, s.title || title));
                return;
              }
              if (obj.suites) {
                obj.suites.forEach(s => collectFailures(s, out, s.title || title));
                return;
              }
              if (obj.tests) {
                obj.tests.forEach(t => collectFailures(t, out, title));
                return;
              }
              if (obj.results) {
                const failed = obj.results.find(r => r.status === 'failed' || r.status === 'timedOut');
                if (failed && (failed.error || failed.errorMessage)) {
                  const err = failed.error || { message: failed.errorMessage || 'Unknown' };
                  const msg = (err.message || '').split('\n')[0].trim().slice(0, 400);
                  out.push({ title: title || 'Test', message: msg });
                }
                return;
              }
              if (obj.status === 'failed' && obj.error) {
                const msg = (obj.error.message || '').split('\n')[0].trim().slice(0, 400);
                out.push({ title: title || obj.title || 'Test', message: msg });
              }
            }

            let failureSummary = '';
            const jsonPath = path.join(process.env.GITHUB_WORKSPACE || '.', 'e2e-results-artifact', 'e2e-results.json');
            try {
              if (!fs.existsSync(jsonPath)) {
                failureSummary = 'E2E results artifact not found (run may have failed before report was written). Check the workflow log and artifacts.';
              } else {
              const raw = fs.readFileSync(jsonPath, 'utf8');
              const data = JSON.parse(raw);
              const failures = [];
              collectFailures(data, failures, '');
              const unique = failures.filter((f, i) => failures.findIndex(x => x.title === f.title && x.message === f.message) === i);
              if (unique.length > 0) {
                failureSummary = unique.slice(0, 5).map(f => `- **${f.title}**: ${f.message}`).join('\n');
              }
              }
            } catch (e) {
              failureSummary = '(Could not parse e2e-results.json: ' + (e.message || e.code || 'unknown') + ')';
            }

            let explanation = failureSummary || 'One or more E2E tests failed. See artifacts for details.';

            const hasFailureBullets = failureSummary && failureSummary.includes('**: ');
            if (process.env.OPENAI_API_KEY && hasFailureBullets) {
              try {
                const res = await fetch('https://api.openai.com/v1/chat/completions', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + process.env.OPENAI_API_KEY
                  },
                  body: JSON.stringify({
                    model: 'gpt-4o-mini',
                    messages: [
                      { role: 'system', content: 'You explain E2E test failures for developers in 2-4 short sentences. Be specific to the error (e.g. overlay blocking clicks, timeout, missing element). Suggest the most likely fix when obvious.' },
                      { role: 'user', content: 'Summarize this E2E failure for a PR comment:\n\n' + failureSummary }
                    ],
                    max_tokens: 280,
                    temperature: 0.2
                  })
                });
                const data = await res.json();
                if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
                  explanation = data.choices[0].message.content.trim();
                }
              } catch (e) {
                explanation = '## E2E failures\n\n' + failureSummary + '\n\n*(OpenAI summary unavailable; see artifacts for full details.)*';
              }
            } else if (failureSummary) {
              explanation = '## E2E failures\n\n' + failureSummary;
            }

            const runUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            const body = `## E2E tests failed

            ${explanation}

            **Artifacts:** [playwright-report](${runUrl}), [test-screenshots](${runUrl}), [test-videos](${runUrl}) (download from this run). Re-run the workflow if the failure looks flaky.`;

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
